#ifndef _PLANNER_LOCAL_
#define _PLANNER_LOCAL_

#include <ros/ros.h>
#include <vector>

#include <base_local_planner/trajectory_planner_ros.h>
#include <base_local_planner/trajectory_planner.h>
#include <costmap_2d/costmap_2d.h>
#include <costmap_2d/costmap_2d_ros.h>
#include <tf/transform_listener.h>

#include <nav_msgs/Path.h>
#include <geometry_msgs/Twist.h>



namespace semantic_planner 
{
	class PlannerLocal : public base_local_planner::TrajectoryPlannerROS
    {
    public:
    	/**
         * @brief  Default constructor for the SemanticPlannerGlobal object
         */
	    PlannerLocal();

	    /**
         * @brief  Constructor for the SemanticPlannerGlobal object
         * @param  tf A reference to a TransformListener
         */
        PlannerLocal(std::string name,
                           tf::TransformListener* tf, ros::NodeHandle &nh,
                           costmap_2d::Costmap2DROS* costmap_ros);

        /**
         * @brief  Constructs the ros wrapper
         * @param name The name to give this instance of the trajectory planner
         * @param tf A pointer to a transform listener
         * @param costmap The cost map to use for assigning costs to trajectories
         */
        void initialize(std::string name, tf::TransformListener* tf, ros::NodeHandle &nh, costmap_2d::Costmap2DROS* costmap_ros);

        
        
        /**
	     * @brief  Default deconstructor for the SemanticPlannerGlobal object
         */
        ~PlannerLocal();

        bool sendVelocityCommands();
        void stop();

        bool isInitialized() 
        {
        	return initialized_;
        }

        bool initialized_;


    private:

    	

    	std::vector<double> loadYVels(ros::NodeHandle node);

        base_local_planner::WorldModel* world_model_; ///< @brief The world model that the controller will use
    	base_local_planner::TrajectoryPlanner* tc_; ///< @brief The trajectory controller
        base_local_planner::MapGridVisualizer map_viz_; ///< @brief The map grid visualizer for outputting the potential field generated by the cost function

    	costmap_2d::Costmap2DROS* costmap_ros_; ///< @brief The ROS wrapper for the costmap the controller will use
        costmap_2d::Costmap2D* costmap_; ///< @brief The costmap the controller will use

        ros::NodeHandle nh_;
        tf::TransformListener* tf_; ///< @brief Used for transforming point clouds
        std::string global_frame_; ///< @brief The frame in which the controller will run
        std::string robot_base_frame_; ///< @brief Used as the base frame id of the robot

        double xy_goal_tolerance_, yaw_goal_tolerance_, min_in_place_vel_th_;
        double max_vel_th_, min_vel_th_;
        double acc_lim_x_, acc_lim_y_, acc_lim_theta_;
        double sim_period_;
        double max_sensor_range_; ///< @brief Keep track of the effective maximum range of our sensors
        bool rotating_to_goal_;
        bool reached_goal_;
        bool latch_xy_goal_tolerance_, xy_tolerance_latch_;
        bool setup_;
        std::vector<geometry_msgs::Point> footprint_spec_;

        base_local_planner::OdometryHelperRos odom_helper_;

        // Publishers
        ros::Publisher local_plan_pub_;
        ros::Publisher vel_pub_;

    };




}
#endif