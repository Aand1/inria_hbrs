/*********************************************************************
 *
 * Software License Agreement (BSD License)
 *
 *  Copyright (c) 2015, Hochschule Bonn-Rhein-Sieg, Germany
 *                      Inria, France
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.
 *   * Neither the name of Hochschule Bonn-Rhein-Sieg, Germany and Inria, 
 *     France nor the names of its contributors may be used to 
 *     endorse or promote products derived from this software without 
 *     specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: Niranjan Vilas Deshpande
 *         (niranjan.deshpande187@gmail.com)
 *
 * Supervised by: Sven Schneider (Hochschule Bonn-Rhein-Sieg)
 *                Prof. Dr. Paul G. Ploeger (Hochschule Bonn-Rhein-Sieg)
 *		          Dr. Anne Spalanzani (Inria)
 *********************************************************************/

#include <semantic_costmap/inflate_objects.h>

namespace semantic_costmap
{
	InflateObjects::InflateObjects(costmap_2d::LayeredCostmap* parent, tf::TransformListener *tf, std::string name)
		:  tf_(tf),
		   name_(name)
	{
		layered_costmap_ = parent;
		access_ = new boost::shared_mutex();
		costmap_ = NULL;

		initialize();


	}
	
	InflateObjects::~InflateObjects()
	{
		
	}

	void InflateObjects::initialize()
	{
		boost::unique_lock < boost::shared_mutex > lock(*access_);
		ros::NodeHandle nh("~/" + name_), g_nh;
    	current_ = true;

    	//seen_ = NULL;
    	// Initialize inflation related parameters
    	inflation_radius_ = 0.5;
    	inscribed_radius_ = 0.25;

    	// Context and semantic information related parameters initialization
		context_weight_ = 10.0;
      	semantic_weight_ = 10.0;
      	context_factor_ = 1.0;
      	semantic_factor_ = 1.0;

    	seen_ = NULL;

    	cell_inflation_radius_ = cellDistance(inflation_radius_);

    	InflateObjects::matchSize();

    	semantic_map_query = new semantic_map::SemanticMap(nh);
		

	}

	void InflateObjects::updateBounds(double robot_x, double robot_y, double robot_yaw, double* min_x, double* min_y,
                            double* max_x, double* max_y)
	{
		object_list = semantic_map_query->getSemanticMap();
		//semantic_map_query->getSemanticMap();

		
	}

	void InflateObjects::updateCosts(costmap_2d::Costmap2D& master_grid, int min_i, int min_j, int max_i, int max_j)
	{
		ROS_INFO_STREAM("updateCosts");
		inflation_queue_.empty();

		unsigned char* master_array = master_grid.getCharMap();
    	unsigned int size_x = master_grid.getSizeInCellsX(), size_y = master_grid.getSizeInCellsY();

  		std::memset(seen_, false, size_x * size_y * sizeof(bool));

    	unsigned char cost;

    	unsigned int mx, my, omx, omy;

		std::list<semantic_map::Object>::iterator obs_it;
		for (obs_it = object_list.begin(); obs_it != object_list.end(); ++obs_it)
    	{
    		semantic_map::Object& object = *obs_it;

    		double min_x = 1000.0;
    		double min_y = 1000.0;
			double max_x = 0.0;
			double max_y = 0.0;

			for ( int i = 0; i < object.geometry.bounding_box.vertices.size(); i++ )
    		{
	    		double wx = object.geometry.bounding_box.vertices[i].x;
	    		double wy = object.geometry.bounding_box.vertices[i].y;

	    		layered_costmap_->getCostmap()->worldToMap(wx, wy, mx, my);

	    		double center_x = object.geometry.pose.position.x;
	    		double center_y = object.geometry.pose.position.y;
	    		layered_costmap_->getCostmap()->worldToMap(center_x, center_y, omx, omy);
	
	    		double res = layered_costmap_->getCostmap()->getResolution();
	    		double factor = 0.5;

	    		int dx = mx - omx;
	    		int dy = my - omy;
	    		
	    		double h = sqrt(dx*dx+dy*dy) + factor/res;
	    		double angle = atan2(dy,dx);

	    		double x = mx + cos(angle) * h;
	    		double y = my + sin(angle) * h;

	    		min_x = std::min(min_x, x);
	            min_y = std::min(min_y, y);
	            max_x = std::max(max_x, x);
	            max_y = std::max(max_y, y);

    		}

    		/*ROS_INFO_STREAM(min_x);
    		ROS_INFO_STREAM(min_y);
    		ROS_INFO_STREAM(max_x);
    		ROS_INFO_STREAM(max_y);
    		ROS_INFO_STREAM("+++++++++++++++++");*/
    		
    		
    		for (int x = min_x; x < max_x; x++)
	    	{
	    		//unsigned int it = x * span + min_y;
	    		for (int y = min_y; y < max_y; y++)
	    		{
	    			int index = master_grid.getIndex(x, y);
      				unsigned char cost = master_array[index];
      				if (cost == costmap_2d::LETHAL_OBSTACLE)
      				{
        				//ROS_INFO_STREAM("LETHAL");
        				enqueue(master_array, index, y, x, y, x);
      				}
      				//else
      				//{ 
	    				//double distance = distanceLookup(x, y, omx, omy);
	    				//cost = computeCost(distance);
	    			//}
	    			//master_array[index] = cost;

	    				//ROS_INFO_STREAM(distance);
	    		/*	cost = layered_costmap_->getCostmap()->getCost(x, y);
	    			//ROS_INFO_STREAM(cost);
	    			//std::cout << cost << std::endl;
	    			if ( cost < costmap_2d::LETHAL_OBSTACLE - 1 )
	    			//	ROS_INFO_STREAM("hi");
	    			    layered_costmap_->getCostmap()->setCost(x, y, costmap_2d::LETHAL_OBSTACLE);*/
	    			//if ( master_array[it] < costmap_2d::LETHAL_OBSTACLE)
	    			/*{
	    				unsigned int index = getIndex(x, y);
	    				master_array[index] = 200.0;
	    				//ROS_INFO_STREAM(index);
	    			}*/
	    			//it++;

	    		}
	    	}

	    	while (!inflation_queue_.empty())
			{
			    //get the highest priority cell and pop it off the priority queue
			    const CellData& current_cell = inflation_queue_.top();

			    unsigned int index = current_cell.index_;
			    unsigned int mx = current_cell.x_;
			    unsigned int my = current_cell.y_;
			    unsigned int sx = current_cell.src_x_;
			    unsigned int sy = current_cell.src_y_;

			    //pop once we have our cell info
			    inflation_queue_.pop();

			    //attempt to put the neighbors of the current cell onto the queue
			    if (mx > 0)
			      enqueue(master_array, index - 1, mx - 1, my, sx, sy);
			    if (my > 0)
			      enqueue(master_array, index - size_x, mx, my - 1, sx, sy);
			    if (mx < size_x - 1)
			      enqueue(master_array, index + 1, mx + 1, my, sx, sy);
			    if (my < size_y - 1)
			      enqueue(master_array, index + size_x, mx, my + 1, sx, sy);
			}

	    	
    	}
    	//ROS_INFO_STREAM(inflation_queue_.size());

    	//updateWithMax(master_grid, min_i, min_j, max_i, max_j);

		
	}

	void InflateObjects::matchSize()
	{
	  //boost::unique_lock < boost::shared_mutex > lock(*access_);
	  costmap_2d::Costmap2D* costmap = layered_costmap_->getCostmap();
	  resolution_ = costmap->getResolution();
	  cell_inflation_radius_ = cellDistance(inflation_radius_);
	  

	  unsigned int size_x = costmap->getSizeInCellsX(), size_y = costmap->getSizeInCellsY();
	  if (seen_)
	    delete seen_;
	  seen_ = new bool[size_x * size_y];
	}

	inline unsigned char InflateObjects::computeCost(double distance) const
  	{
    	unsigned char cost = 0;
    	if (distance == 0)
    		cost = costmap_2d::LETHAL_OBSTACLE;
	    else if (distance * resolution_ <= inscribed_radius_)
	      	cost = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;
	    else
	    {   
		   	// make sure cost falls off by Euclidean distance
      		double euclidean_distance = distance * resolution_;
      		double inflation_distance = euclidean_distance - inscribed_radius_;

      		double final_weight_ = context_factor_*context_weight_ + semantic_factor_*semantic_weight_;

      		double factor = exp(-1.0 * final_weight_ * inflation_distance);
      		
      		cost = (unsigned char)((254 - 1) * factor);
		}
    	return cost;
  	}

	inline double InflateObjects::distanceLookup(int mx, int my, int src_x, int src_y)
	{
	    unsigned int dx = abs(mx - src_x);
	    unsigned int dy = abs(my - src_y);
	    return hypot(dx, dy);
	}

	inline void InflateObjects::enqueue(unsigned char* grid, unsigned int index, unsigned int mx, unsigned int my,
                                            unsigned int src_x, unsigned int src_y)
	{
		  
	    if (!seen_[index])
	    {
		    //we compute our distance table one cell further than the inflation radius dictates so we can make the check below
		    double distance = distanceLookup(mx, my, src_x, src_y);

		    //we only want to put the cell in the queue if it is within the inflation radius of the obstacle point
		    if (distance > cell_inflation_radius_)
		      return;

		    //assign the cost associated with the distance from an obstacle to the cell
		    unsigned char cost = computeCost(distance);
		    unsigned char old_cost = grid[index];

		    if (old_cost == costmap_2d::NO_INFORMATION && cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE)
		    {
		      grid[index] = cost;
		      //ROS_INFO_STREAM("First condition");
		    }
		    else
		    {
		      grid[index] = std::max(old_cost, cost);
		      
		    }
		    //push the cell data onto the queue and mark
		    seen_[index] = true;
		    CellData data(distance, index, mx, my, src_x, src_y);
		    inflation_queue_.push(data);
	    }
	}

	unsigned int InflateObjects::cellDistance(double world_dist)
	{
	   	return layered_costmap_->getCostmap()->cellDistance(world_dist);
	}

	

};
